####
# NOT IN USE - Vijay Jadhav - Only use if Specific passwords were agreed for the VPN connections with Tenant
#####


## Create a VPN Gateway only
resource "aws_vpn_gateway" "vpn_gateway" {
  vpc_id = data.aws_vpc.selected.id

  tags = merge(
    {
      Name = "vpn-gateway-${var.environment_type}"
    },
    var.tags
  )
}



## Create a customer gateway
resource "aws_customer_gateway" "customer_gateway" {
  bgp_asn    = 65001
  ip_address = var.customer_gateway_ip
  type       = "ipsec.1"

  tags = merge(
    {
      Name = "customer-gateway-${var.environment_type}"
    },
    var.tags
  )
}

## Create an actual vpn connection
resource "aws_vpn_connection" "vpn_connection" {
  customer_gateway_id = aws_customer_gateway.customer_gateway.id
  static_routes_only  = true
  type                = "ipsec.1"
  vpn_gateway_id      = aws_vpn_gateway.vpn_gateway.id

  tunnel1_ike_versions                 = ["ikev2"]
  tunnel2_ike_versions                 = ["ikev2"]
  tunnel1_phase1_encryption_algorithms = ["AES256-GCM-16"]
  tunnel2_phase1_encryption_algorithms = ["AES256-GCM-16"]
  tunnel1_phase1_integrity_algorithms  = ["SHA2-256"]
  tunnel2_phase1_integrity_algorithms  = ["SHA2-256"]
  tunnel1_phase2_encryption_algorithms = ["AES256-GCM-16"]
  tunnel2_phase2_encryption_algorithms = ["AES256-GCM-16"]
  tunnel1_phase2_integrity_algorithms  = ["SHA2-256"]
  tunnel2_phase2_integrity_algorithms  = ["SHA2-256"]

  tunnel1_phase1_lifetime_seconds      = 28800
  tunnel2_phase1_lifetime_seconds      = 28800
  tunnel1_phase2_lifetime_seconds      = 3600
  tunnel2_phase2_lifetime_seconds      = 3600
  tunnel1_phase1_dh_group_numbers      = [19]
  tunnel2_phase1_dh_group_numbers      = [19]
  tunnel1_phase2_dh_group_numbers      = [19]
  tunnel2_phase2_dh_group_numbers      = [19]
  tunnel1_startup_action               = "start"
  tunnel2_startup_action               = "start"
  tunnel1_dpd_timeout_action           = "clear"
  tunnel2_dpd_timeout_action           = "clear"
  # leave the PreShared-Keys commented out : read the "READ THIS" comment below
  # tunnel1_preshared_key                = data.aws_kms_secrets.interpol_prod_tunnel1.plaintext["password"]
  # tunnel2_preshared_key                = data.aws_kms_secrets.interpol_prod_tunnel2.plaintext["password"]
  tunnel1_dpd_timeout_seconds       = 30
  tunnel2_dpd_timeout_seconds       = 30
  tunnel1_rekey_fuzz_percentage     = 100
  tunnel2_rekey_fuzz_percentage     = 100
  tunnel1_rekey_margin_time_seconds = 540
  tunnel2_rekey_margin_time_seconds = 540
  tunnel1_replay_window_size        = 1024
  tunnel2_replay_window_size        = 1024
  # the inside CIDRs are the ones currently used for the Tenant prod IPSec connection
  # we can't specify them in this object as they would re-create the vpn connection (and
  # therefore re-assign new external IP addresses, which isn't good as Tenant would have to
  # change their VPN device's configuration)
  # don't delete them the 2 comments below in case we need to create a new VPN connection
  # with similar attributes to the previous one: re-using the inside CIDRs will mean less
  # re-configuration on the Tenant side
  # tunnel1_inside_cidr               = "169.254.64.12/30"
  # tunnel2_inside_cidr               = "169.254.65.160/30"

  tags = var.tags
}

## Add the static route to VPN
resource "aws_vpn_connection_route" "vpn_connection_route" {
  for_each               = toset(var.vpn_static_route_cidrs)
  destination_cidr_block = each.value
  vpn_connection_id      = aws_vpn_connection.vpn_connection.id
}


################################
# Expand RTB IDs × Destination CIDRs
################################
locals {
  # Every RTB gets every destination CIDR
  rtb_x_dest = {
    for pair in setproduct(var.private_route_table_ids, var.destination_cidr_blocks) :
    "${pair[0]}|${pair[1]}" => { rtb = pair[0], cidr = pair[1] }
  }
}

################################
# VGW routes: many destinations → many RTBs
################################
resource "aws_route" "vgw_routes_multi" {
  for_each = local.rtb_x_dest
  depends_on = [aws_vpn_connection.vpn_connection]
  route_table_id         = each.value.rtb
  destination_cidr_block = each.value.cidr
  gateway_id             = aws_vpn_gateway.vpn_gateway.id
}


# READ THIS
#
# Specific passwords were agreed for the VPN connections with Tenant.
# The passwords were generated by AWS, obtained from the AWS Console and safely encrypted with KMS.
# However, specifying the passwords confuses the terraform AWS provider which alway wants to re-create the resources.
# So, to make sure that future updates to the VPN connection don't re-create it, we are no longer specifying the password.
# Re-creating the connection would be really bad because new external IPs would be assigned automatically, which would
# break the tunnels and need Tenant to update their configuration with the new IPs.
#
# READ THIS

# data "aws_kms_secrets" "tunnel1" {
#   secret {
#     name    = "password"
#     payload = "xx=="
#   }
# }

# data "aws_kms_secrets" "tunnel2" {
#   secret {
#     name    = "password"
#     payload = "xx=="
#   }
# }
